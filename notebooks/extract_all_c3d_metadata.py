# -*- coding: utf-8 -*-
"""Extract all C3D metadata.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v1k2hXq6KTevyWCV3THJRkXVpOKEPCTp
"""

!pip install ezc3d pandas


!wget https://raw.githubusercontent.com/hmok/BiomechPythonAI_Guide/main/notebooks/Chapter1Input.py -O Chapter1Input.py
new_var = %run /content/Chapter1Input.py

# ==== C3D Metadata Dump (Mokka-style) ====
import ezc3d, numpy as np, pandas as pd
from pprint import pprint

# If you already have c3d loaded, reuse it; otherwise set c3d_path:
# c3d_path = "/content/Eb015pi (1).c3d"
try:
    c3d
except NameError:
    c3d = ezc3d.c3d(c3d_path)

P = c3d["parameters"]  # shorthand

def gp(key):   return P.get(key, {})
def val(g,k, default=None):
    try:
        return gp(g)[k]["value"]
    except Exception:
        return default

# ---------- File/stream info ----------
n_frames   = int(c3d["data"]["points"].shape[2])
pt_rate    = float(val("POINT","RATE", [np.nan])[0])
an_rate    = float(val("ANALOG","RATE", [np.nan])[0])
n_points   = int(val("POINT","USED", [0])[0])
n_analog   = int(val("ANALOG","USED", [0])[0])
byte_order = "IEEE Little Endian"  # ezc3d stores little-endian by default
storage    = "Integer"             # most Qualisys/Vicon exports for this file type
# If you need exact endian/storage, you can inspect the raw file header with btk/pyc3dreader.

print("=== FILE INFO ===")
print(f"Frames: 1 â†’ {n_frames} (count {n_frames})")
print(f"Point frequency: {pt_rate} Hz")
print(f"Analog channels: {n_analog}  at  {an_rate} Hz")
print(f"Byte order: {byte_order}")
print(f"Storage: {storage}")
print("")

# ---------- POINT ----------
print("=== POINT GROUP ===")
point = {
    "X_SCREEN": val("POINT","X_SCREEN", ["?"])[0] if val("POINT","X_SCREEN", None) is not None else None,
    "Y_SCREEN": val("POINT","Y_SCREEN", ["?"])[0] if val("POINT","Y_SCREEN", None) is not None else None,
    "UNITS":    val("POINT","UNITS", ["?"])[0],
    "USED":     int(val("POINT","USED", [0])[0]),
    "FRAMES":   int(val("POINT","FRAMES", [n_frames])[0]),
    "SCALE":    float(val("POINT","SCALE", [np.nan])[0]),
    "DATA_START": int(val("POINT","DATA_START", [np.nan])[0]),
    "RATE":     float(val("POINT","RATE", [np.nan])[0]),
}
pprint(point); print("")

# ---------- ANALOG ----------
print("=== ANALOG GROUP ===")
analog = {
    "USED":       int(val("ANALOG","USED", [0])[0]),
    "RATE":       float(val("ANALOG","RATE", [np.nan])[0]),
    "GEN_SCALE":  float(val("ANALOG","GEN_SCALE", [1.0])[0]),
    "UNITS":      val("ANALOG","UNITS", []),
}
pprint(analog)

labels = list(val("ANALOG","LABELS", []))
offsets = list(val("ANALOG","OFFSET", [])) if val("ANALOG","OFFSET", None) is not None else []
scales  = list(val("ANALOG","SCALE",  [])) if val("ANALOG","SCALE",  None) is not None else []

# Build a neat table of channel metadata
df_an = pd.DataFrame({
    "label":  labels,
    "offset": offsets[:len(labels)] if offsets else None,
    "scale":  scales[:len(labels)]  if scales  else None,
    "units":  (val("ANALOG","UNITS", [])[:len(labels)] if val("ANALOG","UNITS", None) else None),
})
print("\nAnalog channels (label/offset/scale/units):")
display(df_an if "display" in globals() else df_an.head(len(labels)))

# ---------- FORCE_PLATFORM ----------
print("\n=== FORCE_PLATFORM GROUP ===")
fp = {
    "USED":        int(val("FORCE_PLATFORM","USED", [0])[0]),
    "TYPE":        list(val("FORCE_PLATFORM","TYPE", [])),
    "CORNERS_dim": np.array(val("FORCE_PLATFORM","CORNERS", [])).shape,
    "ORIGIN_dim":  np.array(val("FORCE_PLATFORM","ORIGIN", [])).shape,
    "CHANNEL_dim": np.array(val("FORCE_PLATFORM","CHANNEL", [])).shape,
    "ZERO":        list(val("FORCE_PLATFORM","ZERO", [])) if val("FORCE_PLATFORM","ZERO", None) is not None else None,
    "TRANSLATION": np.array(val("FORCE_PLATFORM","TRANSLATION", [])).tolist() if val("FORCE_PLATFORM","TRANSLATION", None) is not None else None,
    "ROTATION":    np.array(val("FORCE_PLATFORM","ROTATION", [])).tolist() if val("FORCE_PLATFORM","ROTATION", None) is not None else None,
}
pprint(fp)

# Show first plate's mapping and geometry for reference
try:
    ch = np.array(val("FORCE_PLATFORM","CHANNEL", [])).reshape(6, fp["USED"])
    print("\nCHANNEL mapping (first plate columns are 1-based indices into ANALOG):")
    print(ch[:,0].tolist())
except Exception:
    pass
try:
    corners = np.array(val("FORCE_PLATFORM","CORNERS", [])).reshape(fp["USED"], 3, 4) # (plates, xyz, four corners)
    origin  = np.array(val("FORCE_PLATFORM","ORIGIN",  [])).reshape(fp["USED"], 3)
    print("\nFirst plate CORNERS (m):")
    print(corners[0].tolist())
    print("First plate ORIGIN (m):")
    print(origin[0].tolist())
except Exception:
    pass

# ---------- SUBJECT ----------
print("\n=== SUBJECT GROUP ===")
subject = {
    "NAME":   (val("SUBJECT","NAME",   [""])[0] if val("SUBJECT","NAME", None) else None),
    "NUMBER": (int(val("SUBJECT","NUMBER", [np.nan])[0]) if val("SUBJECT","NUMBER", None) else None),
    "PROJECT":(val("SUBJECT","PROJECT",[""])[0] if val("SUBJECT","PROJECT", None) else None),
    "WEIGHT": (float(val("SUBJECT","WEIGHT",[np.nan])[0]) if val("SUBJECT","WEIGHT", None) else None),
    "HEIGHT": (float(val("SUBJECT","HEIGHT",[np.nan])[0]) if val("SUBJECT","HEIGHT", None) else None),
    "GENDER": (val("SUBJECT","GENDER", [""])[0] if val("SUBJECT","GENDER", None) else None),
    "DATE_OF_BIRTH": (val("SUBJECT","DATE_OF_BIRTH", [""])[0] if val("SUBJECT","DATE_OF_BIRTH", None) else None),
}
pprint(subject)